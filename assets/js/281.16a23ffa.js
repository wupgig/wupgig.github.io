(window.webpackJsonp=window.webpackJsonp||[]).push([[281],{649:function(t,a,s){"use strict";s.r(a);var n=s(47),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"ribbon-客户端负载均衡器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ribbon-客户端负载均衡器"}},[t._v("#")]),t._v(" Ribbon：客户端负载均衡器")]),t._v(" "),s("p",[t._v("在 Spring Cloud 体系中，发起远程调用，本质上就是发起 HTTP 请求。")]),t._v(" "),s("p",[t._v("服务的提供者本质上就是一个 RESTful 风格的 Web 服务，因此，在知道其 API 的情况下我们只要能够发出 HTTP 请求，实际上就『调用』到了这个服务。")]),t._v(" "),s("h2",{attrs:{id:"_1-ribbon-在-resttemplate-中的负载均衡"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-ribbon-在-resttemplate-中的负载均衡"}},[t._v("#")]),t._v(" 1. Ribbon 在 RestTemplate 中的负载均衡")]),t._v(" "),s("p",[t._v("在你没有意识到 Ribbon"),s("small",[t._v("（读作 [ˈrɪbən] ）")]),t._v("存在的时候，Ribbon 就已经可以在你的项目中"),s("small",[t._v("（配合 RestTemplate）")]),t._v("起作用了。")]),t._v(" "),s("p",[t._v("为你的 RestTemplate 的 @Bean 加上 "),s("strong",[t._v("@LoadBalanced")]),t._v(" 注解：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Bean")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@LoadBalanced")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RestTemplate")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("restTemplate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RestTemplate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("blockquote",[s("p",[t._v("@LoadBalanced 注解背后就是 Spring AOP 动态代理的思想。")])]),t._v(" "),s("p",[t._v("你循环调用 RestTemplate，以目标服务在 Nacos Server 上注册的名字来代替 URL 中的 IP 地址，你就会发现有负载均衡的效果：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" url "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"http://SELF-DEPARTMENT/hello"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" str "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" template"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("postForObject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("url"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("str"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("这里之所以能出现负载均衡现象是因为：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("你的项目间接引用到了 Ribbon ，"),s("em",[t._v("spring-cloud-starter-alibaba-nacos-discovery")]),t._v(" 包中已经包含了 ribbon；")]),t._v(" "),s("p",[t._v("当然，你也可以单独引用（"),s("strong",[t._v("spring-cloud-starter-netflix-eureka-ribbon")]),t._v("），不过，逻辑上这就是一句啰嗦的废话。")])]),t._v(" "),s("li",[s("p",[t._v("你的项目是一个 Nacos Client 项目，当它启动时，它会去 Nacos Server 上拉取已注册的所有的服务的 IP 地址等相关信息；")])]),t._v(" "),s("li",[s("p",[t._v("当你通过 RestTemplate 以『"),s("strong",[t._v("application name")]),t._v("』为依据发出请求时，Ribbon 会参与进来，会将 application-name『"),s("strong",[t._v("替换")]),t._v("』成上述第 2 步中查到的 IP 地址。")])]),t._v(" "),s("li",[s("p",[t._v("在『"),s("strong",[t._v("替换")]),t._v("』的过程中，它以某种规则轮流使用同一个服务的多个实例的 IP 地址，从而实现负载均衡效果。这里的『"),s("strong",[t._v("某种规则")]),t._v("』指的就是负载策略。")])]),t._v(" "),s("li",[s("p",[t._v("默认的负载策略是轮循。")])])]),t._v(" "),s("blockquote",[s("p",[t._v("这里需要注意的是，使用了 "),s("strong",[t._v("@LoadBalanced")]),t._v(" 注解之后，RestTemplate 的 URL 中不能再出现 IP:Port，哪怕只有一个单点，也只能出现目标服务在 Nacos Server 上注册的 name。反之亦然。")])]),t._v(" "),s("p",[s("strong",[t._v("Spring Cloud Ribbon")]),t._v(" 不像注册中心、配置中心、网关那样独立部署、运行。它更像是一个工具类"),s("small",[t._v("（库）")]),t._v("，『"),s("strong",[t._v("嵌套")]),t._v("』在各个组件中配合其它组件使用。")]),t._v(" "),s("h2",{attrs:{id:"_2-ribbon-的执行原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-ribbon-的执行原理"}},[t._v("#")]),t._v(" 2. Ribbon 的执行原理")]),t._v(" "),s("p",[t._v("Ribbon 是以拦截器的方式『"),s("strong",[t._v("参与")]),t._v("』到 RestTemplate 的请求发送功能中的。")]),t._v(" "),s("p",[t._v("当我们 RestTemplate 执行请求操作时，就会被 Ribbon 的拦截器拦截。Ribbon 通过 "),s("code",[t._v("request.getURI()")]),t._v(" 方法求能获得 RestTemplate 所发出的请求的 URI，不过此时 URI 中的内容是目标服务的 "),s("em",[t._v("application-name")]),t._v(" 而非 IP 。")]),t._v(" "),s("p",[t._v("由于我们的项目作为 Nacos Client 能够从 Nacos Server 上拉取到 application-name 所对应的一个"),s("small",[t._v("（或多个）")]),t._v("IP 地址及端口信息，因此，Ribbon 会根据某种『"),s("strong",[t._v("规则")]),t._v("』"),s("small",[t._v("（算法）")]),t._v("获取到目标服务的真实的访问路径。")]),t._v(" "),s("p",[t._v("最后，Ribbon 放行 RestTemplate，让它向目标服务继续发起请求"),s("small",[t._v("（并获取返回）")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"_3-负载均衡策略和-irule-接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-负载均衡策略和-irule-接口"}},[t._v("#")]),t._v(" 3. 负载均衡策略和 IRule 接口")]),t._v(" "),s("p",[t._v("前面提到过的『"),s("strong",[t._v("规则")]),t._v("』、『"),s("strong",[t._v("算法")]),t._v("』就是『"),s("strong",[t._v("负载均衡策略")]),t._v("』。")]),t._v(" "),s("p",[t._v("Ribbon 内置了 8 种负载均衡策略"),s("small",[t._v("（其实是 7 种）")]),t._v("，它们都直接或间接实现了 "),s("strong",[t._v("IRule")]),t._v(" 接口：")]),t._v(" "),s("p",[t._v("其中常见的有：")]),t._v(" "),s("ol",[s("li",[s("p",[s("em",[t._v("RandomRule")])]),t._v(" "),s("p",[t._v("随机策略。随机选择目标服务的实例。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("RoundRobinRule")]),t._v("（默认策略）")]),t._v(" "),s("p",[t._v("轮询策略。按顺序循环选择目标服务的实例。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("WeightedResponseTimeRule")])]),t._v(" "),s("p",[t._v("根据响应时间分配一个 Weight（权重），响应时间越长，Weight 越小，被选中的可能性越低。")]),t._v(" "),s("p",[t._v("这个策略以前版本中被称作 "),s("em",[t._v("ResponseTimeWeightedRule")]),t._v(" 。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("BestAvailablRule")])]),t._v(" "),s("p",[t._v("这种策略下，Ribbon 会观测、统计目标服务的各个实例的运行状况、并发量。")]),t._v(" "),s("p",[t._v("当再次发起对目标服务的访问时，Ribbon 会先过滤掉因为多次访问故障而被标记为 Error 的 实例。然后选择一个并发量"),s("small",[t._v("（ActiveRequestCount）")]),t._v("最小的实例发起访问。")]),t._v(" "),s("p",[t._v("俗话说就是：先去掉不能干活的，然后在能干活的里面找一个最闲的。")])])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("上述 4 种策略简单高效，使用较多。而 AvailabilityFilteringRule 和 ZoneAvoidanceRule 策略需要结合断路、超时等参数配置，使用起来比较复杂，容易进坑，所以使用较少。")])]),t._v(" "),s("p",[t._v("Ribbon 默认的负载均衡策略是：轮询，如果我们想调整一下负载均衡策略，可以通过如下的配置。在『服务消费者』的服务中"),s("small",[t._v("（即使用 RestTemplate 发起请求的一方）")]),t._v("，做 Ribbon 负载均衡策略的调整。")]),t._v(" "),s("p",[t._v("目前最简单的方式就是：")]),t._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("SELF-DEPARTMENT")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("ribbon")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("NFLoadBalancerRuleClassName")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" com.netflix.loadbalancer.RandomRule\n")])])]),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),s("p",[t._v("以上配置的仅针对 application-name 为 SELF-DEPARTMENT 的微服务有效。即，若你要调用多个不同的微服务，你要对它们一一配置。")])]),t._v(" "),s("h2",{attrs:{id:"_4-ribbon-的饥饿加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-ribbon-的饥饿加载"}},[t._v("#")]),t._v(" 4. Ribbon 的饥饿加载")]),t._v(" "),s("p",[t._v("默认情况下，服务消费方调用服务提供方接口的时候，第一次请求会慢一些，甚至会超时，而之后的调用就没有问题了。")]),t._v(" "),s("p",[t._v("这是因为 Ribbon 进行客户端负载均衡的 Client 并不是在服务启动的时候就初始化好的，而是在调用的时候才会去创建相应的 Client，所以第一次调用的耗时不仅仅包含发送HTTP请求的时间，还包含了创建 RibbonClient 的时间，这样一来如果创建时间速度较慢，同时设置的超时时间又比较短的话，很容易就会出现上面所描述的现象。")]),t._v(" "),s("p",[t._v("你可以通过启用 Ribbon 的饥饿加载（即，立即加载）模式，并指定在项目启动时就要加载的服务：")]),t._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("ribbon")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("eager-load")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("enabled")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 开启饥饿加载")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("clients")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" aservice"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("sms"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" xxx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" xxx  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 需要饥饿加载的服务")]),t._v("\n")])])]),s("h2",{attrs:{id:"_5-ribbon-的超时和超时重试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-ribbon-的超时和超时重试"}},[t._v("#")]),t._v(" 5. Ribbon 的超时和超时重试")]),t._v(" "),s("p",[t._v("理论上，Ribbon 是有超时设置，以及超时之后的重试功能的。但是，在 RestTemplate 和 Ribbon 结合的方案中，Ribbon 的超时设置和重试设置的配置方式一直在变动，因此有很多『配置无效』的现象，十分诡异。")]),t._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("ribbon")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("restclient")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("enabled")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v("       "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# ribbon 和 RestTemplate 整合使用")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("ReadTimeout")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 请求处理的超时时间，默认值 5000 。")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("MaxAutoRetries")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 最大重试次数，默认值 0 。")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("MaxAutoRetriesNextServer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 切换实例的重试次数，默认值 1 。")]),t._v("\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);