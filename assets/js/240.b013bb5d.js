(window.webpackJsonp=window.webpackJsonp||[]).push([[240],{606:function(e,s,t){"use strict";t.r(s);var i=t(47),v=Object(i.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"redis-集群-1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-集群-1"}},[e._v("#")]),e._v(" Redis 集群（1）")]),e._v(" "),t("p",[e._v("Redis 集群是一个提供在多个 Redis 间节点间共享数据的程序集。")]),e._v(" "),t("blockquote",[t("p",[e._v("Redis 集群并不支持处理多个 keys 的命令，因为这需要在不同的节点间移动数据，从而达不到像 Redis 那样的性能，在高负载的情况下可能会导致不可预料的错误。")])]),e._v(" "),t("p",[e._v("Redis 集群通过分区来提供一定程度的可用性，在实际环境中『"),t("strong",[e._v("当某个节点宕机或者不可达的情况下继续处理命令")]),e._v("』，Redis 集群的优势：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("自动分割数据到不同的节点上。")])]),e._v(" "),t("li",[t("p",[e._v("整个集群的部分节点失败或者不可达的情况下能够继续处理命令。")])])]),e._v(" "),t("h2",{attrs:{id:"redis-主从复制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-主从复制"}},[e._v("#")]),e._v(" Redis 主从复制")]),e._v(" "),t("p",[e._v("主从复制的简单流程介绍：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Master 可以拥有多个 slave 。")])]),e._v(" "),t("li",[t("p",[e._v("多个 slave 可以连接同一个 Master 外，还可以连接到其他的 slave 。")])]),e._v(" "),t("li",[t("p",[e._v("主从复制不会阻塞 Master 在主从复制时，Master 可以处理 client 请求。")])]),e._v(" "),t("li",[t("p",[e._v("提供系统的伸缩性。")])])]),e._v(" "),t("p",[e._v("主从复制简单原理的过程：")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("slave 与 Master 建立连接，发送 sync 同步命令。 也就是说当用户在 Master 写入一条命令后，他们之间会通过一些算法把数据同步到每一个 slave 上。")])]),e._v(" "),t("li",[t("p",[e._v("Msater 会开启一个后台进程，将数据库快照保存到文件中。同时 Master 主进程会开始收集新的写命令并缓存。")])]),e._v(" "),t("li",[t("p",[e._v("后台完成保存后，就将文件发送给 slave 。")])]),e._v(" "),t("li",[t("p",[e._v("slave 将此文件保存在硬盘上。")])])]),e._v(" "),t("h2",{attrs:{id:"redis-sentinel-哨兵-模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-sentinel-哨兵-模式"}},[e._v("#")]),e._v(" Redis Sentinel（哨兵）模式")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Sentinel [ˈsentɪnl] \n")])])]),t("p",[e._v("Sentinel 工作方式：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("每个 Sentinel 以每秒钟一次的频率向它所知的 Master，Slave 以及其他 Sentinel 实例发送一个 PING 命令。")])]),e._v(" "),t("li",[t("p",[e._v("如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 "),t("em",[e._v("down-after-milliseconds")]),e._v(" 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。")])]),e._v(" "),t("li",[t("p",[e._v("如果一个 Master 被标记为主观下线，则正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 的确进入了主观下线状态。")])]),e._v(" "),t("li",[t("p",[e._v("当有足够数量的 Sentinel"),t("small",[e._v("（大于等于配置文件指定的值）")]),e._v("在指定的时间范围内确认 Master 的确进入了主观下线状态， 则 Master 会被标记为客观下线。")])]),e._v(" "),t("li",[t("p",[e._v("在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有 Master，Slave 发送 INFO 命令。")])]),e._v(" "),t("li",[t("p",[e._v("当 Master 被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次。")])]),e._v(" "),t("li",[t("p",[e._v("若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。")])]),e._v(" "),t("li",[t("p",[e._v("若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。")])])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://hemiao3000.gitee.io/java-note-img/images/redis/img/redis-cluster-01.png",alt:"redis-cluster-01"}})])])}),[],!1,null,null,null);s.default=v.exports}}]);