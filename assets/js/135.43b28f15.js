(window.webpackJsonp=window.webpackJsonp||[]).push([[135],{492:function(a,e,v){"use strict";v.r(e);var t=v(47),_=Object(t.a)({},(function(){var a=this,e=a.$createElement,v=a._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"java"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java"}},[a._v("#")]),a._v(" Java")]),a._v(" "),v("h2",{attrs:{id:"java平台概论"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java平台概论"}},[a._v("#")]),a._v(" Java平台概论")]),a._v(" "),v("p",[a._v("Java 根据应用领域的不同，区分为Java SE、Java EE 与 Java ME 三大平台。")]),a._v(" "),v("p",[a._v("Java SE 是各应用平台的基础，分为四个主要的部分：JVM、JRE、JDK 与 Java 语言。")]),a._v(" "),v("p",[a._v("JDK 包括 Java 程序语言、JRE与开发工具；JRE 包括 Java SE API 与 JVM 。")]),a._v(" "),v("p",[a._v("Java 编译时并不直接编译为相依于某平台的0、1序列，而是翻译为中介格式的位码（Byte code）。对 Java 程序而言，只认识一种操作系统，这个系统叫 JVM，位码文件（扩展名为.class的文档）就是JVM的可执行文件。")]),a._v(" "),v("p",[a._v("Java Runtime Environment 就是 Java 执行环境，简称 JRE，包括 Java SE API 与 JVM。只要使用 Java SE API 中的链接库，在安装有 JRE 的计算机上就可以直接运行，无需额外在程序中再包装链接库，而可以由 JRE 直接提供。")]),a._v(" "),v("p",[a._v("JDK 本身附有一个JRE，相对于 Public JRE 这个名称，JDK 自己附有的 JRE 通常称为 Private JRE，只要安装 JDK，一定就有 Private JRE。安装 Public JRE，只不过是方便有另一个 JRE 来模拟客户端的 Public JRE 环境。")]),a._v(" "),v("h2",{attrs:{id:"从-jdk-到-ide"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#从-jdk-到-ide"}},[a._v("#")]),a._v(" 从 JDK 到 IDE")]),a._v(" "),v("p",[a._v("撰写 Java 程序时有几点必须注意：")]),a._v(" "),v("ul",[v("li",[a._v("扩展名为 .java。")]),a._v(" "),v("li",[a._v("主文档名与类名称必须相同。")]),a._v(" "),v("li",[a._v("注意每个字母大小写。")]),a._v(" "),v("li",[a._v("空格只能是半角空格符或Tab字符")])]),a._v(" "),v("p",[a._v("一个 .java 文档可以定义多个类，但是只能有一个类是公开（public）类，而且主文档名必须与公开类名称相同。")]),a._v(" "),v("p",[a._v("规格书中规定 main() 方法的形式一定得是：")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[a._v("public static void main(String[] args)\n")])])]),v("p",[a._v("当你输入一个指令而没有指定路径信息时，操作系统会依照PATH环境变量中设定的路径顺序，依次寻找各路径下是否有这个指令。若系统中安装两个以上JDK，Path路径中设定的顺序，将决定执行哪个JDK下的工具程序，在安装了多个 JDK 或 JRE 的计算机中，确定执行了哪个版本的 JDK 或 JRE 非常重要，确定 PATH 信息是一定要做的动作。")]),a._v(" "),v("p",[a._v("在 JVM 中执行某个可执行文件（.class），就要告诉 JVM 这个虚拟操作系统到哪些路径下寻找文档，方式是通过 CLASSPATH 指定的可执行文件（.class）的路径信息。在启动 JVM 时要告知可执行文件（.class）的位置，可以使用 -classpath 或 -cp 自变量来指定。有的时候，希望也从目前文件夹开始寻找类文件，则可以使用“.”指定。")]),a._v(" "),v("p",[a._v("JAR 文档实际使用 ZIP 格式压缩，当中包含一堆 .class 文档，设定 CLASSPATH 时可将 JAR 文档当做特别的文件夹。如果某个文件夹中有多个 .jar 文档，从 Java SE 6 开始，可以使用“*”表示使用文件夹中所有的 .jar 文档。")]),a._v(" "),v("p",[a._v("在使用 javac 编译程序时，如果要使用到其他类链接库时，也必须使用 -cp 指定 CLASSPATH，使用 -sourcepath 指定寻找原始文档的文件夹，使用 -d 指定编译完成的位码存放文件夹，指定 -verbose 自变量可以看到编译程序进行编译时的过程。")]),a._v(" "),v("p",[a._v("当类原始码开始使用 package 进行分类时，就会具有以下管理上的意义：")]),a._v(" "),v("ul",[v("li",[a._v("原始码文档要放置在与 package 所定义名称层级相同的文件夹层级。")]),a._v(" "),v("li",[a._v("package 所定义名称与 class 所定义名称，会结合而成类的完全吻合名称（Fully qualified name）。")]),a._v(" "),v("li",[a._v("位码文档要放置在与 package 所定义名称层级相同的文件夹层级。")]),a._v(" "),v("li",[a._v("要在包间可以直接使用类或方法必须声明为 public。")]),a._v(" "),v("li",[a._v("import 只是偷懒工具，让你在原始码中不用使用完全吻合名称。")])]),a._v(" "),v("p",[a._v("当找到java可执行文件并执行时，会依照以下规则来寻找可用的 JRE：")]),a._v(" "),v("ul",[v("li",[a._v("可否在 java 可执行文件文件夹下找到相关原生（Native）链接库。")]),a._v(" "),v("li",[a._v("可否在上一层目录中找到 jre 目录。")])]),a._v(" "),v("h2",{attrs:{id:"基础语法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基础语法"}},[a._v("#")]),a._v(" 基础语法")]),a._v(" "),v("p",[a._v("在 Java 中的基本类型主要可区分为整数、字节、浮点数、字符与布尔。整数可细分为short整数（2字节）、int整数（4字节）与long整数（8字节）。byte类型顾名思义，长度就是一个字节。浮点数可分为float浮点数（4字节）与double浮点数（8字节）。char 类型用来存储'A'、'B' '中' 等字符符号。在JDK7中，Java的字符采用Unicode 6.0 编码，JVM成果采用 UTF-16 Big Endian，所以每个字符数据类型占两个字节。boolean 类型可表示true和false。如果存储值超出类型范围，称为溢值，会造成程序不可预期的结果。")]),a._v(" "),v("p",[a._v("在程序中看到"),v("code",[a._v("//")]),a._v("符号，这时Java程序的单行注释，另一个注释符号是"),v("code",[a._v("/*")]),a._v("和"),v("code",[a._v("*/")]),a._v("包含的多行注释。")]),a._v(" "),v("p",[a._v("数据暂存的位置在程序编程语言中称为变量。对于基本类型来说，想要声明何种类型的变量，就使用byte、short、int、long、float、double、char、boolean 等关键字来声明。变量在声明时有一些规则，它不可以使用数字开头，也不可以使用一些特殊符号，而且变量名不可以与Java关键词同名，也不能与Java保留字同名。")]),a._v(" "),v("p",[a._v("在 Java 领域中的命名惯例，通常会以小写字母开始，并在每个单子开始时第一个字母使用大写，称为驼峰命名法。")]),a._v(" "),v("p",[a._v("在方法中声明的变量称为局部变量，不可以声明局部变量后未指定任何值给它之前就使用变量，编译程序遇到这种情况也会编译错误。在声明变量时加上 final 限定，如果后续撰写程序时，自己或别人不轻易像修改final变量，就会出现编译错误。")]),a._v(" "),v("p",[a._v("在 Java SE 7 之后，撰写整数或浮点数字面常量时可以使用下划线更清楚地表示某些数字。")]),a._v(" "),v("p",[a._v("==是由两个连续的=组成，而不是一个，一个=是一个指定运算，这一点必须特别注意。")]),a._v(" "),v("p",[a._v("&&与||有所谓的快捷方式运算。因为AND只要其中一个为假，就可以判定为假；OR 只要有一个为真，就可以判定结果为真。")]),a._v(" "),v("p",[a._v("将++或--运算符写在变量前，表示先将变量值加或减1，然后再返回变量值。将++或--运算符写在变量后，表示先返回变量值，然后再对变量加或减1。")]),a._v(" "),v("p",[a._v("在程序中写下一个浮点数，编译程序默认会使用double类型。程序中写下一个整数时，默认是使用int类型。如果表达式中包括不同类型数值，则运算时以长度最长的类型为主，其他数值类型自动提升类型。")]),a._v(" "),v("p",[a._v("在 JDK7 之后，switch 可用于比较整数、字符、字符串 与 Enum。")]),a._v(" "),v("p",[a._v("for循环语法的圆括号中，初始式只执行一次，所以通常用来声明或初始化变量，如果是声明变量，结束for循环后变量就会消失。第一个分号后，则是每次执行循环体前会执行一次，且必须是true或false的结果，true 就会执行循环体，false 就会结束循环。第二个分号，则是每次执行完循环体后会执行一次。for 圆括号中的每个描述区块时以分号“;”作分隔，而在一个描述区块中若想写两个以上的描述句，则使用逗号“，”作分隔。")]),a._v(" "),v("hr"),a._v(" "),v("h2",{attrs:{id:"认识对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#认识对象"}},[a._v("#")]),a._v(" 认识对象")]),a._v(" "),v("p",[a._v("要产生对象必须先定义类，类是对象的设计图，对象时类的实例。类定义时使用class关键字，建立实例要使用new关键词。以类名称声明的变量，称为参考名称、参考变量或直接叫参考。")]),a._v(" "),v("p",[a._v("想在建立对象时，一并进行某个初始化流程，像是指定数据成员值，则可以定义构造函数，构造函数是与类名称同名的方法。参数名称与对象数据成员同名时，可以在数据成员前使用this区别。")]),a._v(" "),v("p",[a._v("java.util.Scanner 的 nextInt() 方法会看看标准输入中，有没有输入下一个字符串（以空格或换行符分隔），有的话会尝试将之解析为int类型，其他的还有nextByte()、nextShort()、nextLong()、nextFloat()、nextDouble()、nextBoolean() 等。如果直接取得上一个字符串（以空格或换行分隔），则使用next()，如果想取得用户输入的整行文字，则使用nextLine()（以换行分隔）。")]),a._v(" "),v("p",[a._v("Java 遵守 IEEE 754 浮点数运算规则，使用分数与指数来表示浮点数。如果要求精确度，那就要小心使用浮点数，而且别用==直接标胶浮点运算结果。可以使用 java.math.BigDecimal 类得到想要的精确度。")]),a._v(" "),v("p",[a._v("= 是用在指定参考名称参考某个对象，而 == 是用在比较两个参考名称是否参考同一个对象。")]),a._v(" "),v("p",[a._v("要让基本类型对象一样操作，可以使用Long、Integer、Double、Float、Boolean、Byte 等类来打包基本类型，这些类就是所谓的打包器。除了使用new创建基本类型打包器之外，从 J2SE 5.0 之后提供了自动装箱功能。自动装箱与拆箱的功能事实上是编译程序蜜糖。")]),a._v(" "),v("p",[a._v("数组在Java中就是对象，索引由0开始，存取超出索引范围，就会抛出 ArrayIndexOutOfBoundException 错误。从 JDK5 之后，有了更方便的增强式for循环语法，可用于循环取得数组元素。使用new建立数组后，每个索引元素都会有默认值。在Java中，数组一旦建立，长度就固定了。")]),a._v(" "),v("p",[a._v("无论 System.arraycopy() 还是 Arrays.copyOf()，用在类类型声明的数组时，都是在执行浅层复制。")]),a._v(" "),v("p",[a._v("字符串本质是打包字符数组的对象，是 java.lang.String 类的实例。在启动 JVM 并指定执行类时，可以一并指定命令行自行变量，会收集为 String 数组，由 main() 中的 args 参考。")]),a._v(" "),v("p",[a._v("以“”包括的字符串，只要内容相同（序列、大小写相同），无论是在程序代码中出现几次，JVM 都只会建立一个String实例，并在字符串池中维护。如果想比较字符串实际字符内容是否相同，不要使用==，要使用equal()。")]),a._v(" "),v("p",[a._v("字符串对象一旦建立，就无法更改对象中任何内容，对象上没有任何方法可以改变字符串内容。使用+连接字符会产生新的String对象，不要将+用在重复性的连接场合。")]),a._v(" "),v("p",[a._v("使用javac指令没有指定-encoding选项时，会使用操作系统默认编码。")]),a._v(" "),v("hr"),a._v(" "),v("h2",{attrs:{id:"对象封装"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对象封装"}},[a._v("#")]),a._v(" 对象封装")]),a._v(" "),v("p",[a._v("构造函数实现对象初始化流程的封装。方法封装了操作对象的流程。Java 中还可以使用 private 封装对象私有数据成员。封装的目的主要就是隐藏对象细节，将对象当做黑箱操作。")]),a._v(" "),v("p",[a._v("在 Java 命名规范中，取值方法的名称形式是固定的，也就是以get开头，之后接上首字母大写的单词。")]),a._v(" "),v("p",[a._v("如果没有声明权限修饰的成员，只有在相同包的类程序代码中才可以直接存取，也就是“包范围权限”。如果想在其他包的类程序代码中存取某包的类或对象成员，则该类或对象成员必须是公开成员，在Java中要使用 public 加以声明。")]),a._v(" "),v("p",[a._v("创建对象时，数据成员就会初始化，如果没有指定初始值，则会使用默认初始化。")]),a._v(" "),v("p",[a._v("如果定义类时，没有撰写任何构造函数，编译器会自动加入一个无参、内容为空的构造函数，称为默认构造函数。可以定义多个构造函数，只要参数类型或参数个数不同，这称为重载构造函数。")]),a._v(" "),v("p",[a._v("定义方法时可以进行重载，可为类似功能的方法提供统一名称，但根据参数类型或个数的不同调用对应的方法。")]),a._v(" "),v("p",[a._v("编译程序在处理重载方法时，会依以下顺序来处理：")]),a._v(" "),v("ul",[v("li",[a._v("还没有装箱动作前可符合自变量个数与类型的方法。")]),a._v(" "),v("li",[a._v("装箱动作后可符合自变量个数与类型的方法。")]),a._v(" "),v("li",[a._v("尝试有不定长度自变量并可符合自变量类型的方法。")]),a._v(" "),v("li",[a._v("找不到合适的方法，编译错误。")])]),a._v(" "),v("p",[a._v("除了被声明为 static 的地方外，this 关键字可以出现在实现类中任何地方，在对象创建后为“这个对象”的参考名称。this()代表调用另一个构造函数，至于调用哪个构造函数，则视调用this()时给的自变量类型与个数而定。")]),a._v(" "),v("p",[a._v("如果对象数据成员被声明为 final，但没有明确使用 = 指定符，那表示延迟对象成员值得指定，在构造函数执行流程中，一定要有队该数据成员指定值的动作，否则编译错误。")]),a._v(" "),v("p",[a._v("被声明为static的成员，不会让个别对象拥有，而是属于类。")]),a._v(" "),v("p",[a._v("在 static 方法或区域中不能出现 this 关键字。static 方法中不能用非static数据或方法成员。")]),a._v(" "),v("p",[a._v("在 JDK5 之后支持不定长自变量，为编译程序蜜糖，展开后变为数组。使用不定长自变量时，方法上声明的不定长参数必须是参数列表最后一个，使用两个以上不定长自变量是非法的。")]),a._v(" "),v("hr"),a._v(" "),v("p",[a._v("##6. 继承与多态")]),a._v(" "),v("p",[a._v("面向对象中，子类继承父类，避免重复的行为定义。")]),a._v(" "),v("p",[a._v("在Java中，继承时使用 extends 关键字，private 成员也会被继承，只不过子类无法直接存取，必须通过父类提供的方法来存取（如果父类愿意提供访问方法的话）。")]),a._v(" "),v("p",[a._v("在Java中，子类只能继承一个父类，继承有个重要的关系，就是子类和父类之间会有is-a的关系。要开始理解多态时，必须先知道你操作的对象是“哪一种”东西。")]),a._v(" "),v("p",[a._v("检查多台语法逻辑是否正确，方法是从=号右边往左读：右边是不是一种左边呢（右边类型是不是左边类型的子类）？如果不是就会编译出错，如果加上扮演（CAST）语法，编译程序就会让程序代码通过编译，不过后果得自行负责，也就是扮演失败，执行时会抛出 ClassCastException。")]),a._v(" "),v("p",[a._v("什么叫做多态？以抽象讲法解释，就是使用单一接口操作多种类型的对象。")]),a._v(" "),v("p",[a._v("如果某方法区块中真的没有任何程序代码操作，可以使用 abstract 标示该方法为抽象方法，该方法不用撰写{}区域，直接“;”结束即可。类中若有方法没有操作，并且标示为abstract，表示这个类定义不完整，定义不完整的类就不能用来生成实例。Java 中规定内含抽象方法的类，一定要在class前标示abstract，表示这是一个类定义不完整的抽象类。")]),a._v(" "),v("p",[a._v("被声明为 protected 的成员，相同的包中的类可以直接存取，不同包中的类可以在继承后的自雷直接存取。")]),a._v(" "),v("p",[a._v("Java 中有 public、protected 与 private 三个权限关键字，但是实际上有四个权限范围。")]),a._v(" "),v("p",[a._v("如果想要取得父类中的方法定义，可以在调用方法前，加上 super 关键字。重新定义方法要注意，对于父类中的方法权限，只能扩大但不能缩小。在 JDK5 之后，重新定义方法时，如果返回类型是父类中方法返回类型的子类，也是可以通过编译的。")]),a._v(" "),v("p",[a._v("如果子类构造函数中没有指定执行父类中哪个构造函数，默认会调用父类中无参数构造函数。如果想执行父类中某构造函数，可以使用 super() 指定。this() 与 super() 只能择一调用，而且一定要在构造函数第一行执行。")]),a._v(" "),v("p",[a._v("如果 class 前使用了 finale 关键字定义，那么表示这个类是最后一个了，不会再有子类，也就是不能被继承。定义方法时，也可以限定该方法final，这表示最后一次定义方法了，也就是子类不可以重新定义final方法。")]),a._v(" "),v("p",[a._v("如果定义类时没有使用 extends 关键字指定任何类，那一定是继承 java.lang.Object。在Java中，任何类追溯至最上层父类，一定就是 Java.lang.Object。")]),a._v(" "),v("p",[a._v("对于不再有用的对象，JVM 有垃圾回收机制，收集到的垃圾对象所占据的内存空间，会被垃圾收集器释放。执行流程中，无法通过变量参考的对象，就是 GC 认定的垃圾对象。")]),a._v(" "),v("hr"),a._v(" "),v("p",[a._v("##7. 接口与多态")]),a._v(" "),v("p",[a._v("对于“定义行为”，可以使用interface关键字定义，接口中的方法不能操作，直接标示为 abstract，而且一定是public。类要操作接口，必须使用implements 关键字。操作某接口时，对接口中定义的方法有两种处理方式，一是操作接口中定义的方法，二是再度将该方法标示为 abstract。")]),a._v(" "),v("p",[a._v("以 Java 的语义来说，继承会有“是一种”关系，操作接口则表示“拥有行为”，但不会有“是一种”的关系。对于接口多态语法的判断，方式是“右边是不是拥有左边的行为”，或者“右边对象是不是操作了左边接口”。")]),a._v(" "),v("p",[a._v("类可以操作两个以上的类，也就是拥有两种以上的行为。类可以同时继承某个类，并操作某个些接口。接口可以继承自另一个接口，也就是继承父接口行为，再在子接口中额外定义行为。")]),a._v(" "),v("p",[a._v("使用 interface 来定义抽象的行为外观，方法要声明为 public abstract，无须且不能有操作。为了方便，也可以省略 public abstract，编译程序会协助补齐。")]),a._v(" "),v("p",[a._v("可以使用接口枚举常数，只能定义为 public static final。为了方便，public static final 可以省略，编译程序协助补齐。")]),a._v(" "),v("p",[a._v("如果有两个接口都定义了某方法，操作两个接口的类并不会有错误，照样通过编译，但在设计上要思考一下：两个接口都有定义的方法是否表示不同的行为？")]),a._v(" "),v("p",[a._v("接口可以继承别的接口，也可以同时继承两个以上的接口，同样也是使用 extends 关键字，这代表了继承父接口的行为。")]),a._v(" "),v("p",[a._v("从 JDK5 之后新增了 enum 语法，可用于定义枚举常数。enum 定义了特殊的类，继承自 java.lang.Enum，不过这是由编译程序处理，直接撰写程序继承 Enum 类会被编译程序拒绝。")]),a._v(" "),v("p",[a._v("enum 实际上定义了了，而 enum 中列举的常数，实际上是 public static final，且为枚举类型，无法撰写程序直接实例化枚举类型，因为构造函数权限限定为 private，只有类中才可以实例化。")]),a._v(" "),v("hr"),a._v(" "),v("p",[a._v("##8. 异常处理")]),a._v(" "),v("p",[a._v("Java 中所有错误都会被打包为对象，JVM 会尝试执行 try 区域块中的程序代码，如果发生错误，执行流程会跳离错误发生点，然后比较 catch 括号中声明的类型，是否符合被抛出的错误对象类型，如果是的话，就执行 catch 区块中的程序代码。")]),a._v(" "),v("p",[a._v("错误对象都继承自 java.lang.Throwable 类，Throwable 定义了取得错误信息、堆栈追踪等方法，它有两个子类：java.lang.Error 与 java.lang.Exception。")]),a._v(" "),v("p",[a._v("Error 与其子类实例代表严重系统错误，Error 对象抛出时，基本上不用处理，任其传播至JVM为止，或者是最多留下日志信息。")]),a._v(" "),v("p",[a._v("通常程序中会使用try、catch 加以处理的错误，都是 Exception 或其子类实例，所以通常称错误为异常处理，对于某些异常，可以 try、catch 语法尝试将应用程序恢复至可执行状态。")]),a._v(" "),v("p",[a._v("如果某个方法声明会抛出 Throwable、Exception 或 子类实例，但又不属于 java.lang.RuntimeException 或其子类实例，就必须明确使用 try、catch 语法加以处理，或者用 throws 声明这个方法会抛出异常，否则会编译失败。")]),a._v(" "),v("p",[a._v("Throwable、Exception 或其子对象，但非属于 RuntimeException 或 其子类对象，称为受检异常。")]),a._v(" "),v("p",[a._v("属于 RuntimeException 衍生出来的类实例，通常是实现无法预测错误是否发生的执行期异常，编译程序不会强迫一定得在语法上加以处理，称为非受检异常。")]),a._v(" "),v("p",[a._v("如果父类异常在子类异常对象前被捕捉，则 catch 子类异常对象的区块将永远不会被执行，编译程序会检查出这个错误。")]),a._v(" "),v("p",[a._v("从 JDK7 开始，可以使用多重捕捉语法，不过仍得注意异常的继承，catch 括号中，左边的异常不得是右边异常的父类型，否则会发生编译错误。")]),a._v(" "),v("p",[a._v("操作对象的过程中如果会抛出受检异常，但目前环境信息不足以处理异常，所以无法使用try、catch处理时，可由方法的客户端依据当时调用的环境信息进行处理。为了告诉编译程序这个事实，必须使用throws声明此方法会抛出的异常类型或父类型，编译程序才会让你通过编译。")]),a._v(" "),v("p",[a._v("如果是非受检异常，原本就是可以自行选择是否处理异常，因此不使用 try、catch 处理时也不用特别在方法上使用 throws 声明，不处理非受检处理时，异常会自动往外传播。")]),a._v(" "),v("p",[a._v("在 catch 区域进行完部分错误处理之后，可以使用throw（注意，不是throws）将异常再抛出。")]),a._v(" "),v("p",[a._v("在 JDK7 中，编译程序对于重新抛出的异常类型可以更精确判断。")]),a._v(" "),v("p",[a._v("若想得知异常发生的根源，以及多重方法调用下异常的堆栈传播，可以利用异常对象自动收集的堆栈追踪来取得相关信息，例如，调用异常对象的 printStackTrace()、getStackTrace() 等方法。")]),a._v(" "),v("p",[a._v("在使用 throw 重抛异常时，异常的追踪堆栈起点，仍是异常的发生根源，而不是重抛异常的地方。如果想要让异常堆栈起点为重抛异常的地方，可以使用fillStackTrace()，这个方法会重新装填异常堆栈，将起点设为重抛异常的地方，并返回 Throwable 对象。")]),a._v(" "),v("p",[a._v("无论 try 区块中有无异常发生，若撰写有finally区块，则finally区块一定会执行。无论程序撰写的流程中先return了，而且也有finally区块，finally区块会先执行完后，再将值返回。")]),a._v(" "),v("p",[a._v("在 JDK7 之后，新增了尝试关闭资源（try-with-resources）语法，想要尝试自动关闭资源的对象，是撰写在try之后的括号中。")]),a._v(" "),v("p",[a._v("若一个异常被catch后的处理过程中引发另一个异常，通常会抛出第一个作为响应，addSuppressed() 方法是 JDK7 在 java.lang.Throwable 中新增的方法，可将第二个异常记录在第一个异常之中，JDK7 中与之相对应的是 getSuppressed() 方法，可返回 Throwable[]，代表先前被 addSuppressed() 记录的各个异常对象。")]),a._v(" "),v("p",[a._v("JDK7 的尝试关闭资源语法可套用的对象，必须操作 java.lang.AutoCloseable 接口，这是 JDK7 新增的接口。尝试关闭资源语法也可以同时关闭两个以上的对象资源，只要中间以分号间隔。在try的括号中，越写在后面的对象资源会越早被关闭。")]),a._v(" "),v("hr"),a._v(" "),v("p",[a._v("##Collection 与 Map")]),a._v(" "),v("p",[a._v("收集对象的行为，像是新增对象的add()方法，移除对象的remove()方法等，都是定义在 java.util.Collection 中。既然可以手机对象，也要能逐一取得对象，这就是 java.lang.Iterable 定义的行为，它定义了 iterator() 方法返回 java.util.Iterator 操作对象，可以让你逐一取得收集的对象。")]),a._v(" "),v("ul",[v("li",[a._v("如果希望收集时记录每个对象的索引顺序，并可依靠索引取回对象，这样的行为定义在 java.util.List 接口中。")]),a._v(" "),v("li",[a._v("如果希望收集的对象不重复，具有集合的行为，则由 java.util.Set 定义。")]),a._v(" "),v("li",[a._v("如果希望收集对象时可以队列方式，收集的对象加入至尾端，取得对象时可以从前端，则可以使用 java.util.Queue。")]),a._v(" "),v("li",[a._v("如果希望可以对Queue 的两端进行加入、移除等操作，则可以使用 java.util.Deque。")])]),a._v(" "),v("p",[a._v("数组在内存中会是连续的线性空间，根据索引随机存取时速度快，如果操作上有这类需求时，像是排序，就可使用ArrayList，可得到较好的速度表现。")]),a._v(" "),v("p",[a._v("数组在内存中会是连续的线性空间，如果需要调整索引顺序时，会有较差的表现。数组的长度固定也是要考虑的问题，在 ArrayList 内部数组长度不够时，会建立新数组，并将旧数组的参考指定给新数组，这也是必须消耗时间和内存的操作，ArrayList 有个可指定容量的构造函数。如果大致知道将收集的对象范围，事先建立足够长度的内部数组，可以节省以上所描述的成本。")]),a._v(" "),v("p",[a._v("LinkedList 在操作List接口时，采用了链接结构，不会事先消耗内存，想要指定索引随机存取对象时，会比较没有效率，链接的每个元素会参考下一个元素，这有利于调整索引顺序。若收集的对象经常会有变动索引的情况，也许考虑链接方式操作的List会比较好。")]),a._v(" "),v("p",[a._v("Java 中许多要判断对象是否重复时，都会调用 hashCode() 与 equal() 方法，因此规格书中建议，两个方法必须同时操作。")]),a._v(" "),v("p",[a._v("如果对象有操作 Queue，并打算以队列方式使用，且队列长度受限，通常建议使用 offer()、poll() 与 peek() 等方法。想对队列的前端与尾端进行操作，在前端加入对象与取出对象，在尾端加入对象与取出对象，Queue的子接口Deque 就定义了这类行为。")]),a._v(" "),v("p",[a._v("无论 List、Set 还是 Queue，都会有个 iterator() 方法，这个方法在 JDK 1.4 之前，是定义在 Collection 接口中，而 List、Set、Queue 继承自 Collection，所以也都拥有 iterator() 的行为。在 JDK5 之后，原先定义在 Collection 中的 iterator() 方法，提升至新的 java.util.Iterator 父接口，增强式for循环可运用在数组上，还可运用在操作 Iterable 接口的对象上。增强式for循环是编译程序蜜糖。")]),a._v(" "),v("p",[a._v("在 Java 的规范中，跟顺序有关的行为，通常要不对象本身是Comparable，要不就是另行指定 Comparator 对象告知如何排序。")]),a._v(" "),v("p",[a._v("从 JDK5 之后，新增了泛型语法，让你在设置 API 时可以指定类或方法支持泛型，而使用 API 的客户端在语法上会更为简洁，并得到编译时期检查。")]),a._v(" "),v("p",[a._v("可以事先利用 java.util.Map 接口的操作对象来建立键值对应数据，之后若要取得值，只要用对应的键就可以迅速取得。判断键是否重复根据 hashCode() 与 equal()，所以作为键的对象必须操作 hashCode() 与 equals()。")]),a._v(" "),v("p",[a._v("一般常用 Properties 的 setProperty() 指定字符串类型的键值，getProperty() 指定字符串类型的键，取回字符串类型的值，通常称为属性名称与属性值。")]),a._v(" "),v("p",[a._v("如果想取得 Map 中所有键，可以调用 Map 的 keySet() 返回 Set 对象，如果想取得 Map 中所有的值，则可以使用 values() 返回 Collection 对象。如果想同时取得 Map 的键与值，可以使用 entrySet() 方法，返回一个 set 对象，每个元素都是 Map.Entry 实例，可以调用getKey()取得键，调用 getValue() 取得值。")]),a._v(" "),v("hr"),a._v(" "),v("p",[a._v("##10. 输入/输出")]),a._v(" "),v("p",[a._v("从应用程序角度来看，如果要将数据从来源取出，可以使用输入串流；如果要将数据写入目的地，可以使用输出串流。在 Java 中，输入串流代表对象为 java.io.InputStream 实例，输出串流代表对象为 java.io.OutputStream 的实例，接下来操作输入/输出的方式都是一致，无须理会来源或目的地的真正形式。")]),a._v(" "),v("p",[a._v("在不使用 InputStream 与 OutputStream 时，必须使用 close() 方法关闭串流。由于 InputStream 与 OutputStream 操作了 java.io.Closeable 接口，其父接口为 java.lang.AutoCloseable 接口，因此可使用 JDK7 尝试关闭资源语法。")]),a._v(" "),v("p",[a._v("FileInputStream 是 InputStream 的子类，可以指定文件名创建实例，一旦创建文件就开启，接着就可以来读取数据。FileOutputStream 是 OutputStream 的子类，可以指定文件名创建实例，一旦创建文档就开启，接着就可以用来写出数据。无论 FileInputStream 还是 FileOutputStream，不使用时都要使用close()关闭文档。")]),a._v(" "),v("p",[a._v("ByteArrayInputStream 是 InputStream 的子类，可以指定 byte 数组 创建实例，一旦创建就可将 byte 数组当作数据源进行读取。ByteArrayOutputStream 是 OutputStream 的子类，可以指定byte数组创建实例，一旦创建将byte数组当作目的地写出数据。")]),a._v(" "),v("p",[a._v("InputStream、OutputStream 提供串流基本操作，如果想要作为输入/输出的数据做加工处理，则可以使用打包器类。常用的打包器有具备缓冲区作用的 BufferedInputStream、BufferdOutputStream，具备数据转换处理作用的 DataInputStream、DataOutputStream，具备对象串行化能力的 ObjectInputStream、ObjectOutputStream 等。")]),a._v(" "),v("p",[a._v("针对字符数据的读取，JAVA SE 提供了 java.io.Reader 类，其抽象化字符数据读入的来源。针对字符数据的写入，则提供了 java.io.Writer 类，其抽象化数据写出的目的地。")]),a._v(" "),v("p",[a._v("FileReader、FileWriter 则可以对文档做读取与写入，读取或写入时默认会使用操作系统默认编码来做字符转换。在启动 JVM 时，可以指定 -Dfile.encoding 来指定 FileReader、FileWriter 所使用的编码。")]),a._v(" "),v("p",[a._v("Reader、Writer 也有一些修饰器类可供使用。如果串流处理的字节数据，实际上代表某些字符的编码数据，而你想要将这些字节数据转换为对应的编码字符，可以使用 InputStreamReader、OutputStreamReader 对串流数据打包。BufferedReader、BufferedWriter 可对 Reader、Writer 提供缓冲区作用，在处理字符输入/输出时，对效率也会有所帮助。PrintWriter 与 PrintStream 使用上极为类似，不过除了可以对 OutputStream 打包之外，PrintWriter 还可以对 Writer 进行打包，提供 print()、println()、format() 等方法。")]),a._v(" "),v("hr"),a._v(" "),v("h2",{attrs:{id:"_13-线程与并行-api"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-线程与并行-api"}},[a._v("#")]),a._v(" 13. 线程与并行 API")]),a._v(" "),v("p",[a._v("要让目前流程暂定指定时间，可以使用 java.lang.Thread 的静态 sleep() 方法，指定的单位是毫秒，调用这个方法必须处理 java.lang.InterruptedException 。")]),a._v(" "),v("p",[a._v("如果想在 main() 以外独立设计流程，可以撰写类操作 java.lang.Runnable 接口，流程的进入点是操作在 run() 方法中。从 main() 开始的流程会由主线程执行，可以创建 Thread 实例来执行 Runnable 实例定义的 run() 方法，要启动线程执行指定流程，必须调用Thread实例的start()方法。")]),a._v(" "),v("p",[a._v("除了将流程定义在Runnable的run()方法中之外，另一个撰写多线程程序的方式，就是继承 Thread 类，重新定义run()方法。操作 Runnable 接口的好处就是较有弹性，你的类还有机会继承其他类。若继承了 Thread，那该类就是一种 Thread，通常是为了直接利用Thread中定义的一些方法，才会继承Thread来操作。")]),a._v(" "),v("p",[a._v("如果主线程中启动了额外线程，默认会等待被启动的所有线程都执行完run()方法才终止JVM。如果一个Thread被标示为Deamon线程，在所有的非Deamon线程都结束时，JVM 自动就会终止。")]),a._v(" "),v("p",[a._v("在调用Thread实例start()方法后，基本状态为可执行（Runnable）、被阻断（Blocked）、执行中（Running）。")]),a._v(" "),v("p",[a._v("线程有优先权，可使用 Thread 的 setProperty() 方法设定优先权，可设定值位1（Thread.MIN_PRIORITY）到10（Thread.MAX_PRIORITY），默认是5（Thtread.NORM_PRIORITY），超出1到10外的设定值会抛出 IllegaArgumentException。数字越大优先权越高，排班器越优先排入CPU，如果优先权相同，则输流执行。")]),a._v(" "),v("p",[a._v("当某个线程进入Blocked时，将另一个线程排入CPU（成为Running状态），避免CPU空闲下来，经常是改进性能的方式之一。")]),a._v(" "),v("p",[a._v("线程因输入输出进入Blocked状态后，在阻断情况结束后，会回到Runnable状态，等待排班器进入执行（Running状态）。一个进入 Blocked 状态的线程，可以由另一个线程调用该线程的interrupt()方法，让它离开Blocked状态。")]),a._v(" "),v("p",[a._v("如果A线程正在运行，流程中允许B线程加入，等到B线程执行完毕后再继续A线程流程，则可以使用join()方法完成这个需求。")]),a._v(" "),v("p",[a._v("线程完成run() 方法后，就会进入 Dead，进入Dead（或者已经调用过start()）的线程不可以再次调用start()方法，否则会抛出 IllegalThreadStateException 。")]),a._v(" "),v("p",[a._v("Thread 类上定义有stop()方法，不过被标注为 Deprecate。被标注为Deprecated的API，即便没有直接剔除，也意味着不建议程序员再使用它。")]),a._v(" "),v("p",[a._v("如果要停止线程，最好自行操作，让线程跑完所有的流程，而非调用stop()方法。不仅停止线程必须自行根据条件操作，线程的暂停、重启，也必须视需求操作，而不是直接调用 suspend()、resume() 等方法。")]),a._v(" "),v("p",[a._v("每个线程都属于某个线程群组。若在main()主流程中产生一个线程，该线程会属于main线程群组。每个线程产生时，都会归入某个线程群组，这视线程是在哪个群组中产生，如果没有指定，则归入该子线程的线程群组。也可以自行指定线程群组，线程一旦归入某个群组，就无法更换群组。")]),a._v(" "),v("p",[a._v("线程存取同一对象相同资源时可能引发竞速情况，这样的类为不具备线程安全的类。")]),a._v(" "),v("p",[a._v("每个对象都会有个内部锁定，或称为监控锁定。被标示为 synchronized 的区块将会被监控，任何线程要执行 synchronized 区块都必须先取得指定的对象锁定。")]),a._v(" "),v("p",[a._v("如果在方法上标示synchronized，则执行方法必须取得该实例的锁定。synchronize 不只可声明在方法上，也可以描述句方式使用，在线程要执行 synchronize 区块时，必须取得括号中指定的对象锁定。")]),a._v(" "),v("p",[a._v("Java 的 synchronize 提供的是可重入同步，也就是线程取得某对象锁定后，若执行过程又要执行synchronize，尝试取得锁定的对象又是同一个，则可以直接执行。")]),a._v(" "),v("p",[a._v("执行synchronize范围的程序代码期间，若调用锁定对象的wait()方法，线程会释放对象锁定，并进入对象等待集合而处于阻断状态，其他线程可以竞争对象锁，取得锁定的线程可以执行 synchronize 范围的程序代码。")]),a._v(" "),v("p",[a._v("放在等待集合的线程不会参与CPU排班，wait() 可以指定等待时间，时间到之后线程会再次进入排班，如果指定时间0或不确定，则线程会持续等待，直到被中断（调用interrupt()方法）或被告知（notify()方法）可以参与排班。")]),a._v(" "),v("p",[a._v("被竞争锁定的对象调用notify()时，会从对象等待集合中随机通知一个线程加入排班，再次执行synchronize前，被通知的线程会与其他线程共同竞争对象锁定；如果调用notifyAll()，所有等待的线程都会被通知参与排班，这些线程会与其他线程共同竞争对象锁定。")]),a._v(" "),v("hr"),a._v(" "),v("h2",{attrs:{id:"_12-通用-api"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-通用-api"}},[a._v("#")]),a._v(" 12. 通用 API")]),a._v(" "),v("p",[a._v("java.util.logging 包提供了日志功能相关类与接口，不必额外配置日志组件，就可以在标准Java平台使用是其好处。使用日志的起点是Logger类，要取得Logger实例，必须使用 Logger 的静态方法 getLogger()。")]),a._v(" "),v("p",[a._v("调用 getLogger() 时，必须指定 Logger 实例所属名称空间，名称空间以“.”作为层级区分，名称空间层级相同的Logger，其父Logger组态相同。")]),a._v(" "),v("p",[a._v("如果客户端调用了 Logger 实例的 log() 方法，首先会依 Level 过滤信息，再看看 Logger 有无设定 Filter 接口的实例。如果有且其isLoggable()返回true，才会调用Handler实例的publish()方法，Handler也可以设定自己的Filter实例，如果有且isLoggable()返回true，就调用Formatter实例的format()方法格式化信息，最后才调用输出对象将格式化后的信息输出。目前 Logger 的 Handler 处理完，还会穿播给父Logger的所有Handler处理（在通过父Logger层级的情况下）。")]),a._v(" "),v("p",[a._v("可以通过 logging.properties 来设定 Logger 组态，启动JVM时，指定 java.util.logging.config.file 系统属性为 .properties 名称。")]),a._v(" "),v("hr"),a._v(" "),v("p",[a._v("应用程序根据不同地区用户，呈现不同语言，日期格式等称为本地化，如果应用程序设计时，可以在不修改应用程序的情况下，根据不同用户直接采用不同语言，日期格式等，这样的设计考虑称为国际化（internatonalization），简称i18n。")]),a._v(" "),v("p",[a._v("国际化的三个重要概念是地区信息、资源包与基础名称。地区信息的对应类是Locale，ResourceBundle对象是JVM资源包的代表对象。代表同一组信息但不同地区的各个资源包会共享相同的基础名称，使用ResourceBundle的getBundle()时指定的名称，就是在指定基础名称。")]),a._v(" "),v("p",[a._v("使用 ResourceBundle 时，如何根据基础名称取得对应的信息文档：\n（1）使用指定的 Locale 对象取得信息文档。\n（2）使用 Locale.getDefault() 取得的对象取得信息文档。\n（3）使用基础名称取得信息文档。")]),a._v(" "),v("p",[a._v("可以使用Date来取得完整日期时间，可单纯使用toString()取得日期文字描述，或使用 DateFormat 格式化日期。若查看 Date 的 API 文件，会发现许多方法都不再建议使用，而建议改用 Calendar 的相关方法取代。")]),a._v(" "),v("p",[a._v("规则表示式主要用于字符、字符串格式比较，java.util.regex.Pattern 实例是规则表示式在JVM中的代表对象，必须通过Pattern的静态方法compile()来取得，可以使用mather()方法指定要比较的字符串，这会返回 java.util.regex.Matcher 实例，表示对指定字符串的比较器。")]),a._v(" "),v("p",[a._v("NIO2文件系统API提供了一组标准接口与类，应用程序开发者只需要基于这些标准接口与类进行文件系统操作，底层是如何进行文件系统操作，室友文件系统提供者（厂商）负责。")]),a._v(" "),v("p",[a._v("应用程序开发者可以通过 java.nio.file 包中 FileSystem、Paths、Files等类提供的静态方法，取得相关操作系统对象或进行各种文件系统操作，这些静态方法内部会运用FileSystemProvider来取得所需的操作对象，完成应有的操作。")]),a._v(" "),v("hr"),a._v(" "),v("h2",{attrs:{id:"_13-窗口程序设计"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-窗口程序设计"}},[a._v("#")]),a._v(" 13.窗口程序设计")]),a._v(" "),v("hr"),a._v(" "),v("h2",{attrs:{id:"_14-整合数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-整合数据库"}},[a._v("#")]),a._v(" 14.整合数据库")]),a._v(" "),v("p",[a._v("JDBC（Java DataBase Connectivity）是用于执行SQL的解决方案，开发人员使用 JDBC 的标准接口，数据库厂商则对接口进行操作，开发人员无须接触底层数据库驱动程序的差异性。")]),a._v(" "),v("p",[a._v("数据库操作相关的 JDBC 接口或类都位于 java.sql 包中。要连接数据库，可以向 DriverManager 取得 Connection 对象。Connection 是数据库联机的代表对象，一个Connection 对象就代表一个数据库联机。SQLException 是在处理 JDBC 时经常遇到的一个异常对象，为数据库操作过程发生错误时的代表对象。")]),a._v(" "),v("p",[a._v("取得联机等与数据库来源相关的行为规范在 javax.sql.DataBase 接口，实际如何取得 Connection 则由操作接口的对象负责。")]),a._v(" "),v("p",[a._v("Connection 时数据库连接的代表对象，接下来要执行 SQL 的话，必须取得 java.sql.Statement 对象，它是 SQL 描述的代表对象。可使用 Connection 的 createStatement() 来建立 Statement 对象。")]),a._v(" "),v("p",[a._v("Statement 的 executeQuery() 方法则是用于 SELECT 等查询数据库的 SQL，executeUpdate() 方法会返回int结果，表示数据变动的笔数，executeQuery() 会返回 java.sql.ResultSet 对象，代表查询的结果，查询的结果会是一笔一笔的数据。可以使用 ResultSet 的 next() 来移动至下一笔数据，它会返回 true 或 false 表示是否有下一笔数据，接着可以使用 getXXX() 来取得数据。")]),a._v(" "),v("p",[a._v("在使用 Connection、Statement 或 ResultSet 时，要将之关闭并释放相关资源。")]),a._v(" "),v("p",[a._v("如果有些操作只是SQL语句当中某些参数会有所不同，其余的SQL子句皆相同，则可以使用 java.sql.PrepareSatatment。可以使用 Connection 的 prepareStatment() 方法建立一个预先编译的SQL语句，当中参数会变动的部分，先指定“?”这个占位字符。等到需要真正指定参数执行时，再使用相对应的 setInt()、setString() 等方法，指定“?”处真正应该有的参数。")]),a._v(" "),v("hr"),a._v(" "),v("h2",{attrs:{id:"_15-反射与类加载器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_15-反射与类加载器"}},[a._v("#")]),a._v(" 15.反射与类加载器")]),a._v(" "),v("p",[a._v("Java 在真正需要某个类时才会加载对应的.class文件，而非在程序启动就加载所有类。java.lang.Class 的实例代表 Java 应用程序运行时加载的 .class 文档。可以通过 Object 的 getClass() 方法，或者通过.class常量（Class literal）取得每个对象对应的Class对象，如果是基本类型，也可以使用对应的打包类加上.TYPE取得Class对象。例如，Integer.TYPE 可取得代表 int 的 Class 对象。")]),a._v(" "),v("p",[a._v("使用 Integer.TYPE 取得代表int基本类型的Class，如果要取得代表Integer.class文档的Class，则必须使用Integer.class。")]),a._v(" "),v("p",[a._v("编译时期若使用到相关类，编译程序会检查对应的.class文档中记载的信息，以确定是否可完成编译。执行时期使用某类时，会先检查是否有对应的 Class 对象，如果没有，会加载对应的.class文档并生成对应的Class实例。每个类的实例都会知道自己由哪个Class实例生成的。默认使用 getClass() 或 .class 取得的 Class 实例会是同一个对象。")]),a._v(" "),v("p",[a._v("可以使用 Class.forName() 方法实现动态加载类，Class.forName() 方法在找不到指定类时会抛出 ClassNotFoundException 异常。")]),a._v(" "),v("p",[a._v("Class 对象代表加载的.class文档，取得Class对象后，就可以取得与.class文档中记载的信息，像是包、构造函数、方法成员、数据成员等类型。每个类型会有对应的类型，例如包对应类型的 java.lang.Package，构造函数对应的类型是 java.lang.reflect.Constructor，方法成员对应的类型是 java.lang.reflect.Method，数据成员对应类型是 java.lang.reflect.Field 等。")]),a._v(" "),v("p",[a._v("如果实现不知道类名称，可以利用Class.forName() 动态加载.class文档，取得Class对象之后，利用其 newInstance() 方法建立类实例。")]),a._v(" "),v("p",[a._v("若要动态生成数组，必须使用 java.lang.reflect.Array 的 newInstance() 方法。")]),a._v(" "),v("p",[a._v("java.lang.reflect.Method 实例是方法的代表对象，可以使用invoke()方法来动态调用指定的方法。")]),a._v(" "),v("p",[a._v("启动 JVM 并进行初始化动作后产生 Bootstrap Loader，Bootstrap Loader 会产生 Extended Loader，并将 Extended Loader 的父加载器设为 Bootstrap Loader，接着 Bootstrap Loader 会产生 System Loader，并将System Loader 的父加载器设为 Extended Loader。")]),a._v(" "),v("p",[a._v("在加载类时，每个类加载器会先将加载类的任务交给父加载器，如果父加载器找不到，才由自己加载。所以加载器定类时，会以 Bootstrap Loader -> Extended Loader -> System Loader 的顺序寻找类，如果所有的类加载器都找不着指定类，就会抛出 java.lang.NoClassDefFoundError。")]),a._v(" "),v("p",[a._v("类加载器全部继承自抽象类 java.lang.ClassLoader，每个.class 文档加载后，都会有个Class实例来代表。可以由Class 的getClassLoader()取得加载对应.class文档的ClassLoader实例，而ClassLoader的getParent() 方法可以取得父 ClassLoader 实例。")]),a._v(" "),v("p",[a._v("Bootstrap Loader、Extended Loader 与 System Loader 在程序启动后，就无法再改变他们的搜素路径。如果在程序运行过程中，打算动态决定从其他路径加载类，就要产生新的类加载器，新的类加载器建立后，父加载器会设为 System Loader。")]),a._v(" "),v("p",[a._v("由同一类加载器载入的.class文件，只会有一个Class实例。如果同一个.class文档由两个不同的类加载器载入，则会有两份不同的Class实例。")]),a._v(" "),v("hr"),a._v(" "),v("h2",{attrs:{id:"_16-自定义泛型、枚举与注释"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_16-自定义泛型、枚举与注释"}},[a._v("#")]),a._v(" 16. 自定义泛型、枚举与注释")]),a._v(" "),v("p",[a._v("泛型也可以仅定义在方法上，可在方法返回类型前使用 "),v("code",[a._v("<T>")]),a._v(" 定义泛型，之后就可以使用T来定义返回类型、参数类型，或在方法内声明变量、类型转换等。")]),a._v(" "),v("p",[a._v("在定义泛型时，使用extends限制指定T实际类型时，必须是某类的子类。")]),a._v(" "),v("p",[a._v("如果B是A的子类，而 "),v("code",[a._v("Node<B>")]),a._v(" 可视为 "),v("code",[a._v("Node<A>")]),a._v("，则称Node具有共変性（Covariance）或有弹性的（flexible）。Java 的泛型并不具有共変性，不过可以使用类型通配符字符?与extends来声明变量，使其达到类似共変性。")]),a._v(" "),v("p",[a._v("一旦使用通配字符?与extends限定T的类型，就只能通过T声明的名称取得对象指定给Object，或将T声明的名称指定为null。除此之外，不能进行其他指定动作。")]),a._v(" "),v("p",[a._v("如果B是A的子类，而 "),v("code",[a._v("Node<A>")]),a._v(" 视为一种 "),v("code",[a._v("Node<B>")]),a._v("，则称Node具有逆变性。Java泛型并不支持逆变性，可以使用类型通配符?与super来声明，以达到类似逆变性的效果。")]),a._v(" "),v("p",[a._v("Enum 是个抽象类，无法直接实例化，它操作了 Comparable 接口，在 comareTo() 方法中，主要是针对ordinal 成员比较。ordinal 的值会是使用enum枚举的成员顺序，数值由0开始。Enum的equals()与hashCode()基本上继承了Object的行为，但被标注为final。")]),a._v(" "),v("p",[a._v("定义enum时可以自行定义构造函数，条件是不得公开（public）构造函数，也不可以在构造函数中调用super()。")]),a._v(" "),v("p",[a._v("定义enum时有个特定值类本体语法，可用于操作接口或重新定义父类方法。")]),a._v(" "),v("p",[a._v("@Override 在原始码中提供编译程序的信息是，备注是的方法必须是父类或接口中已定义的方法，请编译程序协助是否真的为重新定义方法。如果某个方法原先存在于API中，后来建议不再使用，可以在该方法上注释@Deprecated。可以使用@SuppressWarnings 抑制警告产生，value 属性可以指定要抑制的警告种类。")])])}),[],!1,null,null,null);e.default=_.exports}}]);