(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{471:function(t,v,_){"use strict";_.r(v);var a=_(47),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"多线程-基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多线程-基础"}},[t._v("#")]),t._v(" 多线程：基础")]),t._v(" "),_("h2",{attrs:{id:"认识线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#认识线程"}},[t._v("#")]),t._v(" 认识线程")]),t._v(" "),_("p",[t._v("现代化操作系统都是采用『"),_("strong",[t._v("多任务")]),t._v("』和『"),_("strong",[t._v("分时")]),t._v("』设计，从而诞生了『"),_("strong",[t._v("程序")]),t._v("』和『"),_("strong",[t._v("进程")]),t._v("』的概念，而后又进一步诞生了『"),_("strong",[t._v("线程")]),t._v("』的概念。")]),t._v(" "),_("blockquote",[_("p",[t._v("从历史的时间线来看，『"),_("strong",[t._v("进程")]),t._v("』在前，『"),_("strong",[t._v("线程")]),t._v("』在后。")])]),t._v(" "),_("p",[t._v("『"),_("strong",[t._v("程序")]),t._v("』是对数据描述与操作的代码的集合。")]),t._v(" "),_("p",[t._v("『"),_("strong",[t._v("进程")]),t._v("』是程序的一次动态执行的过程，它对应了从代码加载、执行至执行完毕的一个完整过程。这个过程也是进程从产生、发展至消亡的过程。")]),t._v(" "),_("blockquote",[_("p",[t._v("通俗地说，『程序』是死的，『进程』是活的。进程就是『"),_("strong",[t._v("活着的")]),t._v("』程序。")])]),t._v(" "),_("p",[t._v("『"),_("strong",[t._v("运行程序")]),t._v("』也被称作『"),_("strong",[t._v("执行任务")]),t._v("』,一个操作系统中可以同时运行多个程序也就是同时执行『"),_("strong",[t._v("多个任务")]),t._v("』，那么每个任务就对应一个进程。")]),t._v(" "),_("p",[t._v("在操作系统的管控下，多个进程『"),_("strong",[t._v("轮流")]),t._v("』使用 CPU 资源"),_("small",[t._v("（和其他公共资源）")]),t._v("，这被称作『"),_("strong",[t._v("分时")]),t._v("』。")]),t._v(" "),_("blockquote",[_("p",[t._v("通俗地说，站在 CPU 的角度而言，"),_("strong",[t._v("根本不存在所谓的同时")]),t._v("。这一点很重要。")])]),t._v(" "),_("p",[t._v("进程的特点：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("进程是操作系统运行程序的基本单元；")])]),t._v(" "),_("li",[_("p",[t._v("每一个进程都有自己独立的一块内存空间和一组系统资源；")])]),t._v(" "),_("li",[_("p",[t._v("每一个进程的内部数据和状态是完全独立的。")])])]),t._v(" "),_("h2",{attrs:{id:"线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[t._v("#")]),t._v(" 线程")]),t._v(" "),_("p",[t._v("『线程』是更现代化的概念和技术"),_("small",[t._v("（它的诞生晚于进程）")]),t._v("。线程是『"),_("strong",[t._v("进程中")]),t._v("』的一个单位，即，一个进程可以有多个线程"),_("small",[t._v("（至少有一个），简单来说，就是 "),_("code",[t._v("一对多")]),t._v(" 的关系")]),t._v("。")]),t._v(" "),_("p",[t._v("线程是进程中执行运算的最小单元，一个进程在其执行过程中可以产生多个线程，而线程必须在某个进程内执行。")]),t._v(" "),_("p",[t._v("线程是进程内部的一个执行单元，是可以完成一个独立任务的顺序控制流程。如果在一个进程中同时运行了多个线程，用来完成不同的工作，则称之为『"),_("strong",[t._v("多线程")]),t._v("』。")]),t._v(" "),_("p",[t._v("线程和进程既有联系又有区别：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("一个进程中至少要有一个线程；")])]),t._v(" "),_("li",[_("p",[t._v("操作系统将资源分配给进程，同一个进程的所有线程共享该进程的所有资源；")])]),t._v(" "),_("li",[_("p",[t._v("操作系统将 CPU 分配给线程，即真正在 CPU 上运行的上线程。")])])]),t._v(" "),_("p",[_("strong",[t._v("每个线程都有一个『执行方法』")]),_("small",[t._v("（也叫『"),_("strong",[t._v("入口方法")]),t._v("』）")]),t._v("，每个进程至少拥有的、自动拥有的那个线程的执行方法毫无疑问就是 "),_("strong",[t._v("main")]),t._v(" 方法，因此这个线程也被成为『"),_("strong",[t._v("主线程")]),t._v("』。")]),t._v(" "),_("p",[t._v("每个线程的任务、使命就是去执行它的执行方法。"),_("small",[t._v("线程的执行方法的结束，即意味着线程的生命、使命的完结。")])]),t._v(" "),_("p",[t._v("创建并使用线程的过程可以分为 4 个步骤：")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("定义一个线程类，同时指明这个线程的执行方法")])]),t._v(" "),_("li",[_("p",[t._v("创建线程对象")])]),t._v(" "),_("li",[_("p",[t._v("启动线程")])]),t._v(" "),_("li",[_("p",[t._v("终止线程")])])]),t._v(" "),_("p",[t._v("定义一个线程类通常有两种方法：继承 "),_("strong",[t._v("java.lang.Thread")]),t._v(" 类和实现 "),_("strong",[t._v("java.lang.Runnable")]),t._v(" 接口。")]),t._v(" "),_("h2",{attrs:{id:"使用-thread-类创建线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用-thread-类创建线程"}},[t._v("#")]),t._v(" 使用 Thread 类创建线程")]),t._v(" "),_("p",[t._v("Java 提供了 java.lang.Thread 类支持多线程编程，该类提供了大量的方法来控制和操作线程。")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}},[t._v("#")]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("说明")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("run 方法")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("直接调用线程的执行函数")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("start 方法")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("启动线程")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("sleep 方法")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("让线程休眠"),_("small",[t._v("（即让出 CPU）")]),t._v("指定 "),_("strong",[t._v("毫秒")]),t._v(" 数")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("getName 方法")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("返回该线程的名称")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("getPriority 方法")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("返回线程的优先级")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("setPriority 方法")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("更改线程的优先级")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("getState 方法")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("返回该线程的状态")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("isAlive 方法")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("测试线程是否处于活动状态")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("join 方法")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("等待该线程终止")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("interrupt 方法")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("中断线程")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("yield 方法")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("暂停正在执行的线程，并执行其他线程")])])])]),t._v(" "),_("p",[t._v("使用继承 Thread 类的方式创建线程的实现步骤如下：")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("定义一个类去继承 Thread 类，重写 "),_("strong",[t._v("Thread#run")]),t._v(" 方法，在 "),_("strong",[t._v("Thread#run")]),t._v(" 方法中实现代码逻辑；")])]),t._v(" "),_("li",[_("p",[t._v("创建线程对象;")])]),t._v(" "),_("li",[_("p",[t._v("调用 "),_("strong",[t._v("Thread#start")]),t._v(" 方法启动线程。")])])]),t._v(" "),_("h2",{attrs:{id:"使用-runnable-接口创建线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用-runnable-接口创建线程"}},[t._v("#")]),t._v(" 使用 Runnable 接口创建线程")]),t._v(" "),_("p",[t._v("由于 Java 只允许单继承，因此一旦一个类已有父类，那么就无法再继承 Thread 类，从而导致上述实现线程的方式无法使用。")]),t._v(" "),_("p",[t._v("使用 Runnable 接口创建线程能解决上述问题。")]),t._v(" "),_("p",[t._v("Runnable 接口声明了一个 "),_("strong",[t._v("Runnable#run")]),t._v(" 方法。任何一个类都可以通过实现 Runnable 接口并实现其 "),_("strong",[t._v("Runnable#run")]),t._v(" 方法来完成线程的所有活动。")]),t._v(" "),_("p",[t._v("使用实现 Runnable 接口的方式创建线程的实现步骤如下：")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("定义 Xxx 类并实现 java.lang.Runnable 接口，并实现它所声明的 "),_("strong",[t._v("run")]),t._v(" 方法；")])]),t._v(" "),_("li",[_("p",[t._v("创建线程对象；")])]),t._v(" "),_("li",[_("p",[t._v("调用 "),_("strong",[t._v("start")]),t._v(" 方法启动线程。")])])]),t._v(" "),_("h2",{attrs:{id:"线程的状态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程的状态"}},[t._v("#")]),t._v(" 线程的状态")]),t._v(" "),_("p",[t._v("线程的核心状态有 3 个：")]),t._v(" "),_("ul",[_("li",[t._v("可执行"),_("small",[t._v("（Runnable）")])]),t._v(" "),_("li",[t._v("执行中"),_("small",[t._v("（Running）")])]),t._v(" "),_("li",[t._v("阻塞中"),_("small",[t._v("（Blocking）")])])]),t._v(" "),_("p",[t._v("在加上线程创建之处的短暂的『新生』状态"),_("small",[t._v("（Created）")]),t._v("和销毁前的短暂的『僵尸』状态"),_("small",[t._v("（Zombie）")]),t._v("，从而组成了最常见的线程的 5 种状态。")]),t._v(" "),_("dl",[_("dt",[t._v("新生状态：Created")]),t._v(" "),_("dd",[t._v("创建线程对象后，而又未调用其 Thread#start 方法之前，该线程处于这种状态。此时操作系统还未为其分配资源。")]),t._v(" "),_("dd",[t._v("此时只能启动和终止线程，任何而其他操作都会发生议程。")])]),t._v(" "),_("dl",[_("dt",[t._v("可执行状态：Runnable")]),t._v(" "),_("dd",[t._v("当调用 Thread#start 之后，操作系统为该线程分配了所必须的资源，但是而又未获得 CPU 执行机会时，该线程处于这种状态。")]),t._v(" "),_("dd",[t._v("由于 CPU 时稀缺的公共资源，毫无疑问，在多线程程序中，任意时刻有大量的线程都是处于这种状态。")]),t._v(" "),_("dd",[t._v("通俗的说，这种状态就是『万事俱备，只欠东风』。")])]),t._v(" "),_("dl",[_("dt",[t._v("执行状态：Running")]),t._v(" "),_("dd",[t._v("当前获得 CPU 资源，正在执行的线程，就是处于这种状态。")]),t._v(" "),_("dd",[t._v("对于单核 CPU 而言，一个进程中无论有多少线程，任意时刻有且仅有一个线程是处于该状态。")]),t._v(" "),_("dd",[t._v("同理，对于多核 CPU 而言，"),_("small",[t._v("（全系统无论多少进程多少线程）")]),t._v("N 核 CPU 有且仅有 N 个线程处于这种状态。")])]),t._v(" "),_("dl",[_("dt",[t._v("阻塞状态：Blocked")]),t._v(" "),_("dd",[t._v("一个正在运行（Running）的线程因为某种原因代码逻辑无法再继续运行下去了，就进入阻塞状态。")]),t._v(" "),_("dd",[t._v("进入阻塞状态的线程会让出 CPU，因为即便它强占 CPU 也无法再继续运行下去。")]),t._v(" "),_("dd",[t._v("当造成该线程阻塞的原因小时后，该线程将又有机会运行。")]),t._v(" "),_("dd",[t._v("通俗的说，这种状态就是『除了欠东风，还欠别的』。")])]),t._v(" "),_("p",[t._v("导致一个线程阻塞最常见的原因有以下几个：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("调用了 Thread 类的静态方法 Thread#sleep ;")])]),t._v(" "),_("li",[_("p",[t._v("线程执行 IO 时，无数据可读（或无空间可写）；")])]),t._v(" "),_("li",[_("p",[t._v("一个线程的执行需要获得一个『锁』，而此时锁正被别的线程占用。")])])]),t._v(" "),_("dl",[_("dt",[t._v("僵尸状态：Zombie")]),t._v(" "),_("dd",[t._v("一个线程在结束执行后（无论是正常执行完执行函数，还是被终止掉了），在系统回收分配给它的资源之前，该进程短暂地处于这种状态。")])]),t._v(" "),_("h2",{attrs:{id:"线程的调用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程的调用"}},[t._v("#")]),t._v(" 线程的调用")]),t._v(" "),_("h3",{attrs:{id:"线程的优先级-了解、自学"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程的优先级-了解、自学"}},[t._v("#")]),t._v(" 线程的优先级（了解、自学）")]),t._v(" "),_("p",[t._v("当一个时刻有多个线程处于可运行状态，它们需要排队等待 CPU 资源，每个线程会自动获得一个线程的优先级"),_("small",[t._v("（Priority）")]),t._v("，优先级的高低反映线程的重要或紧急程序。")]),t._v(" "),_("p",[t._v("可运行状态"),_("small",[t._v("（Runnable）")]),t._v("的线程按优先级排队，线程调度依据建立在优先级基础上的『先到先服务』原则。")]),t._v(" "),_("blockquote",[_("p",[t._v("线程的调度是操作系统的重要功能和职责。")]),t._v(" "),_("p",[t._v("线程调度的规则依赖于操作系统内核的实现。有的操作系统会充分遵守优先级规则，有的系统只是将优先级当做『"),_("strong",[t._v("建议值")]),t._v("』，而有的操作系统则完全没有优先级概念、无视优先级，完全随机。")]),t._v(" "),_("p",[_("strong",[t._v("所以不能以优先级作为控制线程先后执行顺序的手段！")])])]),t._v(" "),_("p",[t._v("线程的优先级用 1 ... 10 表示，10 表示优先级最高，默认值是 5。Thread 类中有对应的静态常量：NORM_PRIORITY、MIN_PRIORITY、MAX_PRIORITY 。")]),t._v(" "),_("p",[t._v("线程的优先级可以通过 "),_("strong",[t._v("Thread#setPriority(int level)")]),t._v(" 方法更改。")]),t._v(" "),_("h3",{attrs:{id:"实现线程调度的方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现线程调度的方法"}},[t._v("#")]),t._v(" 实现线程调度的方法")]),t._v(" "),_("p",[t._v("线程调度的实现核心思路只有一个："),_("strong",[t._v("通过各种手段，迫使一个线程"),_("small",[t._v("（通常是当前执行线程）")]),t._v("让出 CPU ，从而让其它线程拥有执行机会")]),t._v("。")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("手段一："),_("strong",[t._v("Thread#join")]),t._v(" 方法")]),t._v(" "),_("p",[t._v("Thread#join 方法会导致当前线程阻塞"),_("small",[t._v("（让出 CPU）")]),t._v("，等待调用该方法的线程"),_("small",[t._v("（即，Thread 对象所代表的那个线程）")]),t._v("结束后再继续执行本线程。")])]),t._v(" "),_("li",[_("p",[t._v("手段二："),_("strong",[t._v("Thread.sleep")]),t._v(" 方法")]),t._v(" "),_("p",[t._v("Thread.sleep 方法会导致当前线程睡眠"),_("small",[t._v("（本质上也是阻塞，迫使当前线程让出 CPU）")]),t._v("，在指定时间到期后，重新进入可运行状态。")])]),t._v(" "),_("li",[_("p",[t._v("手段三："),_("strong",[t._v("Thread.yield")]),t._v(" 方法")]),t._v(" "),_("p",[t._v("Thread.yield 方法稍微有点不同，它让当前线程让出 CPU ，但并不是进入阻塞状态，而是直接进入 Runnable 状态。")])])]),t._v(" "),_("p",[t._v("需要注意的是，当前线程让出 CPU 之后，接下来是哪个线程执行"),_("small",[t._v("（从 Runnable 状态变为 Running 状态）")]),t._v("带有『"),_("strong",[t._v("不确定性")]),t._v("』。")]),t._v(" "),_("h3",{attrs:{id:"线程的同步与互斥"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程的同步与互斥"}},[t._v("#")]),t._v(" 线程的同步与互斥")]),t._v(" "),_("p",[t._v("当两个或多个线程需要访问同一资源"),_("small",[t._v("（或执行同一段代码时）")]),t._v("，需要某一时刻只能被一个线程使用的方式，称为线程『"),_("strong",[t._v("互斥")]),t._v("』。")]),t._v(" "),_("p",[t._v("当两个或多个线程以互斥的方式访问完同一资源"),_("small",[t._v("（或执行同一段代码）")]),t._v("后，『通知』其他线程的方式，称为线程『"),_("strong",[t._v("同步")]),t._v("』。")]),t._v(" "),_("blockquote",[_("p",[t._v("同步与互斥通常总是一起出现的。只出现互斥，不出现同步，意味着代码逻辑是一种极简单的多线程状况。")])]),t._v(" "),_("h3",{attrs:{id:"synchronized-关键字"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-关键字"}},[t._v("#")]),t._v(" synchronized 关键字")]),t._v(" "),_("p",[t._v("使用 "),_("strong",[t._v("synchronized")]),t._v(" 关键字修饰的方法控制对类成员变量的访问。每个类实例都对应一把锁，方法一旦执行，就独占该锁，直到方法结束时才将锁释放；此后其它被阻塞的线程才能获得该锁，重新进入可执行状态。")]),t._v(" "),_("p",[t._v("这种机制保证了同一时刻，对于每一个实例，其所声明为 synchronized 的方法只能有一个处于可执行状态，从而有效地避免了类成员变量的访问冲突。")]),t._v(" "),_("p",[t._v("语法：")]),t._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[t._v("访问修饰符 "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" 返回类型 方法名 "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n")])])]),_("p",[t._v("或")]),t._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" 访问修饰符 返回类型 方法名 "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n")])])]),_("p",[t._v("synchronized 方法的缺陷在于：如果将一个耗时的方法声明为 synchronized 将会使其它线程阻塞时间过长，从而影响系统执行效率和用户体验。")]),t._v(" "),_("p",[t._v("同步代码块是同步方法的缺陷的解决方案，它『锁住』的不是整个方法，而是方法中的一个代码片段。")]),t._v(" "),_("p",[t._v("语法：")]),t._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("一个对象"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),_("p",[t._v("这里的『一个对象』通常是一个字符串常量对象。")]),t._v(" "),_("h2",{attrs:{id:"锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[t._v("#")]),t._v(" 锁")]),t._v(" "),_("p",[t._v("Java 并发 API 对『"),_("strong",[t._v("锁")]),t._v("』提供了支持。锁是一些对象，它们为 synchronized 提供了替代方案。")]),t._v(" "),_("p",[_("strong",[t._v("锁"),_("small",[t._v("（Lock）")])]),t._v(" 不仅能实现 synchronized 的互斥功能，还能进一步实现线程间的同步功能。")]),t._v(" "),_("p",[t._v("锁的工作原理如下：在访问共享资源之前，申请用于保护资源的锁；当资源访问结束完成时，释放锁。当某个线程正在使用锁时，如果另一个线程尝试申请锁，那么后者将会阻塞等待，直到锁被前者释放位置。")]),t._v(" "),_("blockquote",[_("p",[t._v("锁的作用，逻辑上，就是一个令牌、通行证。持有这个令牌、通行证的线程才能继续执行。没有这个令牌、通行证的线程，无法继续执行，直到令牌的持有者放下令牌，而被它拿到后，它才能继续执行。")])]),t._v(" "),_("p",[t._v("所有的锁都要实现 "),_("strong",[t._v("Lock")]),t._v(" 接口，最常用的 Lock 接口的实现类是 "),_("strong",[t._v("ReentrantLock")]),t._v(" 。")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("方法")]),t._v(" "),_("th",[t._v("描述")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("void lock()")]),t._v(" "),_("td",[t._v("进行等待，直到可以获得锁为止")])]),t._v(" "),_("tr",[_("td",[t._v("void lockInterruptibly() throws ...")]),t._v(" "),_("td",[t._v("除非被中断，否则进行等待，直到可以获得锁为止")])]),t._v(" "),_("tr",[_("td",[t._v("Condition newCondition()")]),t._v(" "),_("td",[t._v("返回与调用锁关联的 Condition 对象")])]),t._v(" "),_("tr",[_("td",[t._v("boolean tryLock()")]),t._v(" "),_("td",[t._v("尝试获得锁，如果锁不可获得，立即返回 false；如果可获得，返回 true")])]),t._v(" "),_("tr",[_("td",[t._v("boolean tryLock(long wait, TimeUnit unit) throws ...")]),t._v(" "),_("td",[t._v("在指定时间内，尝试获得锁。如果超出时间后仍无法获得，则返回 false；如果可获得，则返回 true")])]),t._v(" "),_("tr",[_("td",[t._v("void unlock()")]),t._v(" "),_("td",[t._v("释放锁")])])])]),t._v(" "),_("p",[t._v("ReentrantLock 实现了一种可重入锁，当前持有锁的线程能够重复进入这种锁。当然，对于线程重入锁而言，所有 lock ( ) 调用必须有相同数量的 unlock ( ) 调用进行抵消。")])])}),[],!1,null,null,null);v.default=s.exports}}]);