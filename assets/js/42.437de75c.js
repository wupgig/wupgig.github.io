(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{410:function(t,s,e){"use strict";e.r(s);var a=e(47),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"其它"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#其它"}},[t._v("#")]),t._v(" 其它")]),t._v(" "),e("h2",{attrs:{id:"docker容器启动时初始化mysql数据库"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker容器启动时初始化mysql数据库"}},[t._v("#")]),t._v(" Docker容器启动时初始化Mysql数据库")]),t._v(" "),e("h3",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),e("p",[t._v("Docker在开发中使用的越来越多了，最近搞了一个Spring Boot应用，为了方便部署将Mysql也放在Docker中运行。那么怎么初始化 SQL脚本以及数据呢？")]),t._v(" "),e("p",[t._v("我这里有两个传统方案。 第一种方案是在容器启动后手动导入，太low了不行。第二种在Spring Boot客户端连接Mysql容器时初始化数据库，你可以参考"),e("a",{attrs:{href:"https://www.felord.cn/spring-boot-flyway.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("《使用flyway进行数据库版本控制》"),e("OutboundLink")],1),t._v("一文，但是这依赖客户端的能力。能不能做到Mysql容器启动时就自己初始化数据库呢？当然可以！今天就来演示一下。全部代码见文末。")]),t._v(" "),e("h3",{attrs:{id:"原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),e("p",[t._v("当Mysql容器首次启动时，会在 /docker-entrypoint-initdb.d目录下扫描 .sh，.sql，.sql.gz类型的文件。如果这些类型的文件存在，将执行它们来初始化一个数据库。这些文件会按照字母的顺序执行。默认情况下它们会初始化在启动容器时声明的 MYSQL_DATABASE变量定义的数据库中,例如下面的命令会初始化一个REGION_DB 数据库：")]),t._v(" "),e("div",{staticClass:"language-sh extra-class"},[e("pre",{pre:!0,attrs:{class:"language-sh"}},[e("code",[t._v("$ docker run --name some-mysql -e "),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("MYSQL_DATABASE")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("REGION_DB -d mysql:tag\n")])])]),e("p",[t._v("如果你的启动命令没有指定数据库那么就必须在数据库DDL脚本中声明并指定使用该数据库。否则就会实现下面的异常：")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("ERROR 1046 (3D000) at line 7: No database selected\n")])])]),e("p",[t._v("那么接下来我们将利用这一机制来实现Docker容器启动时初始化数据库。")]),t._v(" "),e("h3",{attrs:{id:"自定义dockerfile"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自定义dockerfile"}},[t._v("#")]),t._v(" 自定义Dockerfile")]),t._v(" "),e("p",[t._v("我们编写自己的Dockerfile来实现我们的需求，这里以 Mysql:5.7 为例。不同的版本可能有一定的出入，需要详细去阅读官方文档。脚本如下：")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("FROM mysql:5.7\nLABEL OG=felord.cn\nCOPY utf8mb4.cnf /etc/mysql/conf.d/utf8mb4.cnf\nCOPY ./sql  /tmp/sql\nRUN mv /tmp/sql/*.sql /docker-entrypoint-initdb.d\nRUN rm -rf /tmp/sql\n")])])]),e("ul",[e("li",[t._v("第一步，引入官方 Mysql:5.7 Docker镜像。")]),t._v(" "),e("li",[t._v("第二步，无实际意义，主要是作者、组织信息。")]),t._v(" "),e("li",[t._v("第三步，很重要！本来我没有配置第三行，结果运行容器后发现初始化数据的中文全部乱码了。所以需要在初始化数据库前修改Mysql的编码等配置，这里我顺便把时区也改为了+8:00。")]),t._v(" "),e("li",[t._v("第四步，复制包含数据库脚本的 ./sql文件夹到镜像的/tmp/sql下。")]),t._v(" "),e("li",[t._v("第五步，使用 mv 命令把第四步拷贝的文件夹下的所有.sql文件复制到 /docker-entrypoint-initdb.d下，这样才能利用2.章节的机制进行初始化数据库。")]),t._v(" "),e("li",[t._v("第六步，删除使用过的临时目录。")])]),t._v(" "),e("p",[t._v("然后你可以通过构建镜像命令构建自定义的Mysql镜像：")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 一定不要忘记最后的一个 . 点")]),t._v("\ndocker build -t mysql:5.7c "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v(".")]),t._v("\n")])])]),e("p",[t._v("通过 mysql:5.7c 镜像启动一个名称为 mysql-service 的容器，root 密码为 123456，并持久化数据到宿主机 D:/mysql/data 下：")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[t._v("docker run --name mysql-service -v d:/mysql/data:/var/lib/mysql -p "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3306")]),t._v(":3306 -e "),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("MYSQL_ROOT_PASSWORD")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("123456")]),t._v(" -d mysql:5.7c\n")])])]),e("p",[t._v("小贴士：你可以通过 SHOW VARIABLES LIKE 'character%' 查看字符集是否更改为utf8mb4,也可以通过SHOW VARIABLES LIKE '%time_zone%' 查看时区是否是东八区。")]),t._v(" "),e("h2",{attrs:{id:"docker-的宿主系统是-centos-为什么可以运行-ubuntu-的镜像呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-的宿主系统是-centos-为什么可以运行-ubuntu-的镜像呢"}},[t._v("#")]),t._v(" docker 的宿主系统是 centos，为什么可以运行 ubuntu 的镜像呢？")]),t._v(" "),e("p",[t._v("首先需要区分Linux内核与Linux发行版")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Linux内核是Linux操作系统的核心, 负责硬件管理, 比如管理内存、管理磁盘（文件系统）、管理CPU(进程)等等...")])]),t._v(" "),e("li",[e("p",[t._v("Linux发行版是在Linux内核的基础上添加了一些工具软件,比如图形界面、函数库、软件包管理系统等等...")])])]),t._v(" "),e("p",[t._v("CentOS与Ubuntu是不同的Linux发行版, 它们都是基于Linux内核， 只是添加的工具软件不同。比如， 他们的软件包管理系统不同， CentOS使用yum命令安装软件， 而Ubuntu使用apt-get命令安装软件。")]),t._v(" "),e("p",[t._v("因此CentOS与Ubuntu的内核是相同的(版本可能不同), 只是所安装的软件不同， 即文件系统不同。")]),t._v(" "),e("p",[t._v("Docker容器技术是基于Linux内核实现的， 它主要用到了两个内核模块:")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Namespace： 用于容器的隔离， 例如PID Namespace使得容器中的进程无法感知宿主机以及其他容器中的进程。")])]),t._v(" "),e("li",[e("p",[t._v("Cgroups: 用于容器的资源控制， 比如限制容器所使用的内存大小或者CPU个数。")])])]),t._v(" "),e("p",[t._v("在CentOS上运行基于Ubuntu镜像的容器时, 容器使用了CentOS主机的内核以及Ubuntu镜像, Ubuntu镜像中安装了Ubuntu的各种软件(apt-get)。")])])}),[],!1,null,null,null);s.default=r.exports}}]);